% !TeX spellcheck = en_US
\section{Discussion}
\label{sec_discussion}

\PP{Benefits in other aspects.} \sys uses an alias-aware mining method to 
deduce precise locking rules about whether accesses to a variable should be 
protected by a lock, and which lock is required. Such rules can benefit in 
various aspects. 

First, with these rules, developers can improve the reliability 
and performance of kernel code. On the one hand, developers can carefully check 
whether necessary locks are used when writing code, and avoid serious bugs 
caused by data races in the early developing stage. On the other hand, 
developers can limit the critical zone protected by a lock/unlock pair to the 
exact accesses that should be protected, and let other code can execute 
concurrently. And these locking rules can also help improve documents of OS 
kernels, which is beneficial  for long term evolution of kernel codes.

Second, key fields extracted by \sys are data structure fields that are 
protected by some locks, and this means that these fields are likely to be 
concurrently accessed by different threads. Therefore, key fields can be used 
in detecting various types of concurrency bugs such as use-after-free and 
uninitialized-variable access. Take concurrency use-after-free as an example, 
if a key field is accessed in one thread and freed in another thread, a 
concurrency use-after-free can occur.

Finally, the locking rules deduced by our alias-aware rule mining method can 
enhance other annotation-based analyses such as Clang thread safety 
analysis~\cite{ClangThreadSafety}. Specifically, developers can use 
instrumentation to annotate necessary locks for specific variables in the code 
automatically, according to the locking rules generated by \sys, and run other 
annotation-based analysis to detect data races.

\PP{Comparison to other approaches.} We have tried our best to experimentally 
compare \sys to existing works in data race detection including 
RELAY~\cite{Voung:FSE07}, WHOOP~\cite{Deligiannis:ASE15} and 
Goblint~\cite{Vojdani:ASE16}. Unfortunately, they are too old and generate too 
many errors when compiling and running, and thus we compare \sys to them 
methodologically.



\PP{Limitations and future works.} \sys can be improved in some aspects. First, 
our alias-aware mining method only considers accessed variables and protecting 
locks that exist in the same data structure, and can miss some locking rules 
involving special locks such as RCU locks. To overcome this limitation, we plan 
to create a common virtual node for RCU lock in the alias graph, and regard it 
as the ancestor of all other nodes. In this way, all variables have a common 
ancestor with the RCU lock, and can be inferred to be protected by the RCU 
lock, because the accessed variable and the RCU lock are existing in the 
identical data structure by our alias-aware rule mining method. Second, \sys 
does not handle function-pointer calls, and thus it can not build complete call 
graphs, and thus can miss data races reached from function-pointer calls. To 
relieve this limitation, we plan to apply existing function-pointer 
analysis~\cite{Hind:TOPLAS99, Zhang:ISPEC15, Heintze:PLDI01} in \sys, to detect 
more data races in functions that are called through function pointers and 
reduce false negatives. Third, \sys performs a path-based analysis and suffers 
from high time overhead, to accelerate its analysis, we plan to employ 
summer-based analysis~\cite{Bai:ATC19, Bai:ATC22} to avoid re-analysis of the 
same function definition. Finally, we plan to apply \sys to detect data races 
in other OS kernels such as FreeBSD~\cite{FreeBSD} and NetBSD~\cite{NetBSD}, 
and use it to detect more types of concurrency bugs including use-after-free 
and uninitialized-variable access.