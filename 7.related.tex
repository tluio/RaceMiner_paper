% !TeX spellcheck = en_US
\section{Related Work}
\label{sec_related}

\subsection{Static Analysis of Data Races}
\label{subsec_static}
Many approaches~\cite{Boyapati:OOPSLA02, Anderson:PLDI08, Anderson:PLDI09, 
Zhou:MICRO19, Flanagan:PASTE01, Flanagan:PLDI00, Sadowski:PLATEAU14, 
ClangThreadSafety, Blackshear:OOPSLA18, Choi:PLDI02, Engler:SOSP03, 
Voung:FSE07, Pratikakis:PLDI06, Naik:PLDI06} use static analysis to detect data 
races, without running the checked program. Some of 
them~\cite{Boyapati:OOPSLA02, Anderson:PLDI08, Anderson:PLDI09, Zhou:MICRO19, 
Flanagan:PASTE01, Flanagan:PLDI00, Sadowski:PLATEAU14, ClangThreadSafety} 
perform annotation-based analysis, and request developers to provide locking 
rules about which lock is required when a specific variable is accessed, and 
then detect data races that violate the provided rules. Clang thread safety 
analysis~\cite{ClangThreadSafety} needs developers to annotate code with a {\tt 
GUARDED\_BY} attribute to indicate which lock is required for a specific 
variable, and then works like a type system for multi-threaded 
programs~\cite{Vu:SoICT12, Boyapati:OOPSLA02, Marion:TAMC14} to detect data 
races that violate the provided attribute. Flanagan et 
al.~\cite{Flanagan:PLDI00} design a type system and rely on developers to 
provide additional type annotations to associate a protecting lock with each 
field declaration, and track the set of locks held at each program point. And 
then it identifies whether a given program is race free by checking whether 
necessary locks are indeed held at each program site. However, such 
annotation-based approaches are not suitable for race detection in OS kernels, 
because even an expert developer can not provide accurate annotations, because 
the locking rules of kernel code are not well documented, and the logic of 
kernel code tends to be very complex. Other 
approaches~\cite{Blackshear:OOPSLA18, Choi:PLDI02, Engler:SOSP03, Voung:FSE07, 
Pratikakis:PLDI06, Naik:PLDI06} employ lockset-based analysis to detect data 
races automatically. They deduce locking rules based on statistics instead of 
relying on manual annotations. But they do not consider alias 
relationships~\cite{Voung:FSE07, Engler:SOSP03} or just employ imprecise 
flow-insensitive alias analysis~\cite{Choi:PLDI02, 	Pratikakis:PLDI06, 
Naik:PLDI06}. RacerX~\cite{Engler:SOSP03} performs a lockset analysis to detect 
data races in three modes, including simple checking, simple statistical and 
precise statistical from least to most precise. However, even if for the most 
precise mode, RacerX does not employ any alias analysis, and thus introduces 
many false positives and negatives.

Different from the above static analysis, \sys employs the alias graph to mine 
locking rules automatically. Benefiting from the path-based and field-sensitive 
alias relationships generated by alias graphs, \sys can deduce locking rules 
effectively. With these locking rules, \sys can detect data races accurately. 
Moreover, \sys exploits a pattern-based estimation to extract harmful data 
races automatically, and can help developers focus on data races that can 
indeed introduce serious issues.

\subsection{Dynamic Analysis of Data Races}
\label{subsec_dynamic}
The runtime analysis does not suffer from the pointer alias problems, and thus 
many approaches~\cite{Lochmann:EuroSys19, Lu:SOSP07, Lu:FSE18, Joshi:ASE08, 	
Liu:NSDI07, Ocallahan:PPoPP03, Serebryany:WBIA09, Marino:PLDI09} detects data 
races through dynamic analysis. LockDoc~\cite{Lochmann:EuroSys19} records 
accesses to variables and lock acquisitions of an instrumented Linux kernel in 
logs, and then infers locking rules from the logs. After that, LockDoc 
automatically detect data races by checking whether a given variable access 
violates the inferred locking rules. O'callahan et al.~\cite{Ocallahan:PPoPP03} 
combine lockset-based detection and happens-before-based detection to detect 
data races, which can get fewer false positives and less overhead than previous 
dynamic analyses. In order to reduce runtime overhead further, 
LiteRace~\cite{Marino:PLDI09} employs a sampling-based approach based on the 
hypothesis that data races are likely to occur when a thread is executing
an infrequently accessed region in the program. It instruments sampled memory 
accesses, and performs happens-before-based analysis to detect data races, 
according to the logs generated by the instrumentation.

However, dynamic analysis suffers from low code coverage, and thus the locking 
rules inferred through logs can be imprecise. Besides, dynamic analyses need to 
run OS kernels with instrumentation and are hard to deploy.


